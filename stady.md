# 设计模式之美--重点学习笔记

## 3. 设计原则与思想：面向对象
##### 面向对象定义：
**面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。**
**面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言**

*按照严格的定义，很多语言都不能算得上面向对象编程语言，但按照不严格的定义来讲，现在流行的大部分编程语言都是面向对象编程语言。*

##### 面向对象设计
一个系统由许许多多小的功能模块组成，每个功能模块又由很多的类组成，每个类负责实现什么功能，这就是面向对象分析。将系统如何拆分成模块，模块又如何拆分成一个个的类，类与类之间又如何交互，这就是面向对象设计。

##### 封装
**定义：** 封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。
**意义：** 一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。

##### 抽象
**定义：** 封装主要讲的是如何隐藏信息、保护数据，而抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。
**意义：** 一方面是提高代码的可扩展性、维护性，修改实现不需要改变定义，减少代码的改动范围；另一方面，它也是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。

##### 继承
**定义** 继承是用来表示类之间的 is-a 关系，继承可以分为两种模式，单继承和多继承。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类。
**意义：** 好处：继承最大的好处就是代码复用。坏处：过度使用继承 ，继承层次过深过于复杂，就会导致代码可读性、可维护性变差。
*要多用组合，少用继承*

##### 多态
**定义：** 多态就是子类可以替代父类，父类和子类的实例对象都可以调用父类和子类特有的方法。
**意义：** 多态特性能提高代码的可扩展性和复用性。
实现多态的三个语法机制
+ 第一个语法机制是编程语言要支持父类对象可以引用子类对象。
+ 第二个语法机制是编程语言要支持继承。
+ 第三个语法机制是编程语言要支持子类可以重写（override）父类中的方法。



## 3. 设计原则与思想：设计原则
**设计原则包括：SOLID、KISS、YAGNI、DRY、LOD 等。**
#### SOLID
**S**ingle Responsibility Principle（单一职责原则）
**O**pen Closed Principle（开闭原则）
**L**iskov Substitution Principle（里氏替换原则）
**I**nterface Segregation Principle（接口隔离原则）
**D**ependency Inversion Principle（依赖倒置原则）

### 单一职责原则（SRP）
**定义：**一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的类。
**意义：**单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护性。

**类的指责是否单一判断依据：**不同的应用场景、不同阶段的需求背景、不同的业务层面，对同一个类的职责是否单一，可能会有不同的判定结果。实际上，一些侧面的判断指标更具有指导意义和可执行性，比如，出现下面这些情况就有可能说明这类的设计不满足单一职责原则：
+类中的代码行数、函数或者属性过多；
+类依赖的其他类过多，或者依赖类的其他类过多；
+私有方法过多；
+比较难给类起一个合适的名字；
+类中大量的方法都是集中操作类中的某几个属性。

### 开闭原则（OCP）
**定义：**软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。
**如何理解：**添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。关于定义，我们有两点要注意。第一点是，开闭原则并不是说完全杜绝修改，而是以最小的修改代码的代价来完成新功能的开发。第二点是，同样的代码改动，在粗代码粒度下，可能被认定为“修改”；在细代码粒度下，可能又被认定为“扩展”。
**如何做到开闭原则：**
1. 时刻具备扩展意识、抽象意识、封装意识。
2. 提高代码扩展性；最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式（比如，装饰、策略、模板、职责链、状态）。

### 里式替换原则（LSP）
**定义：**子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。
**意义：**里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。
**里式替换原则与多态之间的区别：**
虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，用来指导继承关系中子类该如何设计，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑及不破坏原有程序的正确性。


### 接口隔离原则（ISP）
**定义：**客户端不应该被强迫依赖它不需要的接口。其中的“客户端”，可以理解为接口的调用者或者使用者。
**如何理解：**理解“接口隔离原则”重点是理解其中的“接口”二字：
1. 如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。
2. 如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。
3. 如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。

**接口隔离原则与单一职责原则之间的区别：**
单一职责原则针对的是模块、类、接口的设计。接口隔离原则相对于单一职责原则，一方面更侧重于接口的设计，另一方面它的思考角度也是不同的。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

### 依赖倒置原则（DIP）
**定义：**：高层模块不要依赖低层模块。高层模块和低层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。
**意义：**依赖倒置原则是面向对象设计的五大设计原则之一，其核心思想是面向接口编程，即面向抽象编程。

**控制反转、依赖注入、依赖注入框架、依赖反转原则之间的区别：**
1. 控制反转：实际上，控制反转是一个比较笼统的设计思想，并不是一种具体的实现方法，一般用来指导框架层面的设计。这里所说的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程通过框架来控制。流程的控制权从程序员“反转”给了框架。
2. 依赖注入：依赖注入和控制反转恰恰相反，它是一种具体的编码技巧。我们不通过 new 的方式在类内部创建依赖类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类来使用。
3. 依赖注入框架：我们通过依赖注入框架提供的扩展点，简单配置一下所有需要的类及其类与类之间依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。
4. 依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。

### KISS原则
**定义：**尽量保持简单。
**意义：**保持代码可读和可维护的重要手段。KISS 原则中的“简单”并不是以代码行数来考量的。代码行数越少并不代表代码越简单，我们还要考虑逻辑复杂度、实现难度、代码的可读性等。而且，本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则。除此之外，同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。
**如何写出满足KISS原则的代码：**
1.不要使用同事可能不懂的技术来实现代码；
2.不要重复造轮子，要善于使用已经有的工具类库；
3.不要过度优化。
### YAGNI 原则
**定义：**不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。
**意义：**YAGNI原则是一种代码设计原则，它强调不要实现那些未来可能会被使用的功能。在软件开发过程中，我们需要尽量避免实现那些未来可能会被使用的功能，因为它们往往是很难被实现、很难被维护的。

### DRY原则
**定义：**不要写重复的代码。
**意义：**DRY原则是软件开发中的一个核心设计原则，它要求我们尽可能减少重复代码的出现。
**判断违反DRY原则：**实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。除此之外，代码执行重复也算是违反 DRY 原则。

**代码复用性：**代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。

**如何提高代码复用性：**
1. 减少代码耦合，
2. 满足单一职责原则
3. 模块化
4. 业务与非业务逻辑分离
5. 通用代码下沉
6. 继承、多态、继承、封装
7. 应用模版等设计模式


### 迪米特法则（LOD）实现“高内聚、松耦合”
**什么是高内聚、松耦合？**
这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。高内聚有助于松耦合，松耦合又需要高内聚的支持。
所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，我们前面讲过的单一职责原则是实现代码高内聚非常有效的设计原则。
所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合。

**定义：**每个模块只应该了解哪些与他关系密切的模块的有限知识。或者说，每个模块只和自己的朋友“说话”，不和陌生人“说话”。(不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的“有限知识”）。)
**意义：**迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。


## 4.范围与重构
### 什么情况下要重构？到底重构什么？又该如何重构？
**重构的定义：**重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。（在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。）

**为什么重构：**重构可以保持代码质量持续处于一个可控状态，不至于腐化到无可救药的地步。对于个人而言，重构非常锻炼一个人的代码能力，并且是一件非常有成就感的事情。它是我们学习的经典设计思想、原则、模式、编程规范等理论知识的练兵场。
**重构什么：**按照重构的规模，我们可以将重构大致分为大规模高层次的重构和小规模低层次的重构。大规模高层次重构包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。这部分工作利用的更多的是比较抽象、比较顶层的设计思想、原则、模式。小规模低层次的重构包括规范命名、注释、修正函数参数过多、消除超大类、提取重复代码等等编程细节问题，主要是针对类、函数级别的重构。小规模低层次的重构更多的是利用编码规范这一理论知识。
**什么时候重构：**一定要建立持续重构意识，把重构作为开发必不可少的部分，融入到日常开发中，而不是等到代码出现很大问题的时候，再大刀阔斧地重构。
**如何重构：**大规模高层次的重构难度比较大，需要组织、有计划地进行，分阶段地小步快跑，时刻让代码处于一个可运行的状态。而小规模低层次的重构，因为影响范围小，改动耗时短，所以，只要你愿意并且有时间，随时随地都可以去做。

### 使重构不出错的落地的技术手段
#### 最可落地执行、最有效的保证重构不出错的手段应该就是单元测试（Unit Testing）。
**什么是单元测试：**单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。
**为什么需要单元测试：**单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是 Code Review）。
1. 单元测试能有效地帮你发现代码中的 bug。
2. 写单元测试能帮你发现代码设计上的问题。
3. 单元测试是对集成测试的有力补充。
4. 写单元测试的过程本身就是代码重构的过程。
5. 阅读单元测试能帮助你快速熟悉代码。
6. 单元测试是 TDD 可落地执行的改进方案。

**什么是代码的可测试性：**粗略地讲，所谓代码的可测试性，就是针对代码编写单元测试的难易程度。对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很费劲，需要依靠单元测试框架中很高级的特性，那往往就意味着代码设计得不够合理，代码的可测试性不好。

**编写可测试性代码的最有效手段：**依赖注入是编写可测试性代码的最有效手段。通过依赖注入，我们在编写单元测试的时候，可以通过 mock 的方法解依赖外部服务，这也是我们在编写单元测试的过程中最有技术挑战的地方。

**有哪些典型的、常见的测试性不好的代码（Anti-Patterns）？**
+ 代码中包含未决行为逻辑
+ 滥用可变全局变量
+ 滥用静态方法
+ 使用复杂的继承关系
+ 高度耦合的代码

### 通过封装、抽象、模块化、中间层等解耦代码
**解耦的重要性：**如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。
**如何给代码解耦？**
1. 封装与抽象：封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。
2. 中间层：引入中间层能简化模块或类之间的依赖关系。
    - 第一阶段：引入一个中间层，包裹老的接口，提供新的接口定义。
    - 第二阶段：新开发的代码依赖中间层提供的新接口。
    - 第三阶段：将依赖老接口的代码改为调用新接口。
    - 第四阶段：确保所有的代码都调用新接口之后，删除掉老的接口。
3. 模块化：将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。


### 快速地改善代码质量的20条编程规范
**一、命名**
- 命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。作用域小的变量（比如临时变量），可以适当地选择短一些的命名方式。除此之外，命名中也可以使用一些耳熟能详的缩写。
- 我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。
- 命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，不要用些反直觉的命名。
- 接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。

**二、注释**
- 注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。
- 注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。